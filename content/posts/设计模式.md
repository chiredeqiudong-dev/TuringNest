---
title: 设计模式
slug: design-patterns
date: 2024-12-08
categories: 学习笔记
tags:
  - java
  - 设计模式
---
# 前言

设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。

设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、**代码设计经验**的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。

根据设计模式的参考书 **Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素）** 中所提到的，总共有 23 种设计模式。这些模式可以分为三大类：创建型模式（Creational Patterns）、结构型模式（Structural Patterns）、行为型模式（Behavioral Patterns）。
# 创建型模式

这类设计模式提供了一种在**创建对象的同时隐藏创建逻辑**的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。

## 工厂模式（Factory Pattern）

>[10分钟了解Java 工厂设计模式](https://www.bilibili.com/video/BV1ux4y157iU?vd_source=7341c7fca3b496e9108bb1fd49c634ef)

工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一，它提供了一种创建对象的方式，使得创建对象的过程与使用对象的过程分离。比如说 Class A 要调用 Class B 的方法，Class A 只需要知道如何使用 Class B 的方法，不需要知道 Class B 内部的改动和实例化 -- **解耦**。

创建对象的过程需要一定的代码量，而且很多地方都会用到，那么就会有很多的*重复代码*。把创建对象的代码放到工厂里统一管理后，我们只需要调用工厂的具体方法，既减少了重复代码，也方便以后对“对象”的创建过程的修改和维护 -- **代码复用**。

使用者只需要知道如何使用以及负责如何用，无须感知创建的逻辑 -- **迪米特法则和单一职责**。

>迪米特法则又称*最少知道原则*（Demeter Principle），最少知道原则是指一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。
>单一职责：在面向对象编程领域中，单一功能原则（Single responsibility principle）规定每个类都应该有一个单一的功能，并且该功能应该由这个类完全封装起来。

工厂模式有以下三种类型。

### 简单工厂模式

![示例](../images/Pasted%20image%2020250305220758.png)


在上图中 Car 接口定义了`showBrand()`展示各自品牌方法，其下三个实现类分别是不同类别车对象。

简单工厂模式与测试类：

![|400](../images/Pasted%20image%2020250305222246.png)

![示例](../images/Pasted%20image%2020250305222128.png)


在简单工厂模式中我们想要知道`宝马`、`奔驰`车的品牌信号，可以通过简单工厂类`SimpleFactory`的一个`createCar(String name)`方法创建，我们不需要知道这些“车”背后的创建逻辑是什么，仅仅使用即可。

这种模式的优点是逻辑简单，封装了创建逻辑，完成了对创建和使用的解耦。但是，当新增多种车型的时候我们需要添加多个`else if`语句，需要不断的修改工厂内部的实现，维护成本较高，不符合**开闭原则**。

>开闭原则（OCP）：开闭原则是开放扩展，关闭修改，简单工厂模式在新增有关 Car 对象时，需要修改工厂内原有的代码，所以不符合OCP。

### 工厂方法模式

工厂方法模式是简单工厂模式的升级版，**通过定义工厂接口来制定规则**，但具体的实现（对象创建）下沉到实现体。

工厂方法模式包含三个主要角色：超级工厂`CarFactory`、具体工厂、具体产品。每个具体工厂负责创建具体产品。


![示例](../images/Pasted%20image%2020250305224330.png)


具体的实现和测试类：


![|600](../images/Pasted%20image%2020250305224605.png)

![](../images/Pasted%20image%2020250305224554.png)


在工厂方法模式中，我们根据不同车的类型来创建不同车的生产工厂，相比于“简单工厂模式”，满足了开闭原则，如果新增车对象，我们只需要实现`CarFactory`接口进行**扩展**即可，不会修改源代码。

该模式也存在不足之处，例如，宝马车工厂只能生产“宝马车”（由`CarFactory`接口内方法决定），如果对宝马车的进行级别划分的活再生产的话，在`BMWFactory`类中就不能直接支持。

### 抽象工厂模式

抽象工厂模式（Abstract Factory Pattern）是围绕一个**超级工厂**创建其他工厂（同工厂方法模式）。该超级工厂又称为其他工厂的工厂。

不同于“工厂方法模式”的是，该模式的**超级工厂**提供了一系列*相关或相互依赖对象*的接口，而在工厂方法模式中只存在一种类型的接口。


![](../images/Pasted%20image%2020250307130844.png)

抽象产品、具体产品：

![](../images/Pasted%20image%2020250307131046.png)


在“抽象工厂模式”中，每个具体工厂负责创建一族相关的具体产品。如奔驰工厂会创建奔驰的B、C不同类型的车。测试如下：


![](../images/Pasted%20image%2020250307131244.png)


抽象工厂模式的优缺点也很明显，优点是保证了产品生产和使用的解耦；避免了重复代码的使用；对于新增产品族也很方便，符合开闭原则。

但是扩展产品族非常困难，增加一个新的产品族需要修改抽象工厂和所有具体工厂的代码。

## 单例模式（Singleton Pattern）

>[10分钟了解Java设计模式-单例模式 ](https://www.bilibili.com/video/BV1Se4y1A7p1/?share_source=copy_web&vd_source=7341c7fca3b496e9108bb1fd49c634ef)

单例模式也是一种创建对象的方式，它确保**一个类只有一个实例**（单例类必须自己创建自己的唯一实例），并提供一个**全局访问点**（给其他所有对象提供这以实例）。

单例模式适用于需要控制实例数量、频繁创建和销毁全局使用的类实例的问题、节省系统资源的场景。

单例模式的实现方式有以下几种：
### 饿汉式单例

所谓饿汉式单例指的是对象*在类加载时就初始化*，在需要该对象时直接使用不需要创建。

代码：

```java
package com.turing.pattern;  

 /**  
  * 饿汉式单例  
  *  
  * @author chiredeqiudong  
  * @date 2025/3/7  
 */
 public class Singleton01 {  
  
    /**  
     * 初始化实例  
     * 使用final关键字确保实例不可重新赋值，保证单例的唯一性  
     */  
    private static final Singleton01 instance = new Singleton01();  
  
    // 私有构造器，确保只有一个实例  
    private Singleton01() {  
    }  
    // 全局访问点  
    public static Singleton01 getInstance() {  
        return instance;  
    }  
  
    // 测试  
    public static void main(String[] args) {  
        System.out.println(Singleton01.getInstance().hashCode() == Singleton01.getInstance().hashCode());  
        // 返回结果：true  
    }  
}
```

使用`final`关键字的具体原因：

1. 防止重新赋值：final 关键字确保 instance 变量一旦被初始化后，就不能再指向其他对象。这保证了单例模式的核心要求，类的唯一实例不会被改变或重新赋值。
2. 线程安全：在多线程环境下，final 关键字可以确保变量的**可见性和不可变性**。当一个 final 字段被正确初始化后，所有线程都能看到该字段的正确值，并且该值不会发生变化。

这种单例模式实现的缺点也很明显，在类加载时就初始化，如果该实例不被使用的话就会一直占用内存，变为垃圾对象，浪费内存。

优点是执行的效率高，代码结构简单。

### 懒汉式单例

懒汉式单例在名字上就和“饿汉式”形成了对比。懒汉式单例的实现方式决定了，只有当第一次调用时才会创建一个唯一实例。

代码：

```java
package com.turing.pattern;  
  
  
/**  
 * 懒汉式单例  
 *  
 * @author chiredeqiudong  
 * @date 2025/3/7  
 */public class Singleton02 {  
  
    private static Singleton02 instance;  
  
    // 私有构造器，确保只有一个实例  
    private Singleton02() {  
    }  
    // 全局访问点  
    public static Singleton02 getInstance() {  
        // 懒汉式体现：需要才创造  
        if (instance == null) {  
            // 仅为了多线程条件下演示  
            try {  
                Thread.sleep(10);  
            } catch (InterruptedException e) {  
                throw new RuntimeException(e);  
            }  
            instance = new Singleton02();  
        }  
        return instance;  
    }  
  
    // 测试  
    public static void main(String[] args) {  
        for (int i = 0; i < 100; i++) {  
            new Thread(() -> {  
                System.out.println(Singleton02.getInstance().hashCode());  
            }).start();  
        }  
    }  
}
```

测试结果：


![](../images/Pasted%20image%2020250307212155.png)


可以发现在多线程模式下上述结果存在问题，解决的方法也很简单我们给`getInstance()`方法上加`synchronized`关键字即可。测试结果如下，实例的哈希码全部一致。


![](../images/Pasted%20image%2020250307212437.png)


在加了锁之后我们程序的执行效率会降低，不过我们可以通过一些方法，在满足单例模式需求的情况下，尽可能的提升效率。

将 `synchronized` 关键字同步的范围缩小，减小锁的粒度，提高效率。

```java
// 全局访问点  
public static Singleton02 getInstance() {  
    // 懒汉式体现：需要才创造  
    synchronized (Singleton02.class) {  
        if (instance == null) {  
            // 仅为了多线程条件下演示  
            try {  
                Thread.sleep(10);  
            } catch (InterruptedException e) {  
                throw new RuntimeException(e);  
            }  
            instance = new Singleton02();  
        }  
    }  
    return instance;
```

>[synchronized不同位置的差异](../文章转载/资料/synchronized不同位置的差异.md)
>[synchronized效率不高的原因](../文章转载/资料/synchronized效率不高的原因.md)

### 双检锁/双重校验锁（DCL，即 double-checked locking）

该种模式也是懒加载的一种，不仅确保了线程安全，而且在多线程的情况下保持高性能。

代码：

```Java
package com.turing.pattern;  
  
  
/**  
 * 双重检查锁  
 *  
 * @author chiredeqiudong  
 * @date 2025/3/7  
 */
 public class Singleton03 {  
  
    // 添加volatile保证内存可见 JIT    
    private static volatile Singleton03 instance;  
  
    // 私有构造器，确保只有一个实例  
    private Singleton03() {  
    }  
    // 全局访问点  
    public static Singleton03 getInstance() {  
        // 两次检查的目的?  
        if (instance == null) {  
            synchronized (Singleton03.class) {  
                if (instance == null) {  
                    try {  
                        Thread.sleep(10);  
                    } catch (InterruptedException e) {  
                        throw new RuntimeException(e);  
                    }  
                    instance = new Singleton03();  
                }  
            }  
        }  
        return instance;  
    }  
  
    // 测试  
    public static void main(String[] args) {  
        for (int i = 0; i < 100; i++) {  
            new Thread(() -> {  
                System.out.println(Singleton03.getInstance().hashCode());  
            }).start();  
        }  
    }  
}
```

>[volatile关键字的底层原理](../文章转载/资料/volatile关键字的底层原理.md)

 两次检查的目的：

1. **减少同步开销**
	1. 第一次检查避免了每次调用 `getInstance` 方法时都进行同步，提高了性能。
	2. 只有在 `instance` 为 `null` 时才进入同步块，进行第二次检查。

2. **确保线程安全**：
	1. 第二次检查确保只有一个实例被创建。防止某线程执行过快实例化后，另一个线程可能会再创建一个 instance。

细想一下，在“懒汉式单例”优化实现的方法中也可以采用“两次检查”。

### 静态内部类/登记形式单例

这种方式能达到双检锁方式一样的功效，但实现更简单。对*静态域使用延迟初始化*，应使用这种方式而不是双检锁方式。这种方式只适用于静态域的情况，双检锁方式可在*实例域需要延迟初始化*时使用。

代码：

```java
package com.turing.pattern;  
  
  
/**  
 * 静态内部类  
 *  
 * @author chiredeqiudong  
 * @date 2025/3/7  
 */
 public class Singleton04 {  
  
    // 静态内部类。懒加载,why？虚拟机规范制度的类“初始化”规则保证。规则? 类的加载顺序？  
    private static class SingletonHolder {  
        private static final Singleton04 INSTANCE = new Singleton04();  
    }  
  
    // 私有构造器，确保只有一个实例  
    private Singleton04() {}  
  
    // 全局访问点  
    public static final Singleton04 getInstance() {  
        return SingletonHolder.INSTANCE;  
    }  
  
    // 测试  
    public static void main(String[] args) {  
        for (int i = 0; i < 100; i++) {  
            new Thread(() -> {  
                System.out.println(Singleton03.getInstance().hashCode());  
            }).start();  
        }  
    }  
}
```

为什么可以实现懒加载？

- 在饿汉式单例实现中，一旦单例类被加载，实例就会被立即创建，这样就没有实现懒加载（lazy loading）。

- 本次实现中，实例不会在类加载时立即被实例化，只有在首次调用 `getInstance` 方法时，才会*加载*相应的单例持有者（SingletonHolder）类，从而实例化单例对象。这是因为[虚拟机规范制度的类“初始化”规则](../文章转载/资料/虚拟机规范制度的类“初始化”规则.md)。

类的加载顺序是什么？

- [虚拟机规范制度的类“初始化”规则](../文章转载/资料/虚拟机规范制度的类“初始化”规则.md)。

- 如果实例化单例对象（instance）非常消耗资源，使用这种懒加载的方式可以有效降低启动时的资源占用。

如何确保线程安全（这里做一个比较）？

1. 饿汉式单例的类加载机制：实例是在类加载时创建的，而类加载是由 JVM 严格控制的。JVM确保类的静态初始化是线程安全的，即当类被加载到 JVM 中时，静态变量的初始化只会执行一次，并且这个过程是原子性的。

2. 静态内部类单例的类加载机制：静态内部类`SingletonHolder`只有在第一次调用`getInstance()`方法时才会被加载和初始化。JVM 同样确保类的初始化是线程安全的，即当多个线程同时调用`getInstance()`方法时，`SingletonHolder`类只会被加载并初始化一次。

这种实现方式更为合理，因为它能够避免提前初始化实例而带来的*不必要的开销*，同时又确保了多线程环境下的*安全性*。

### 枚举单例

通过枚举保证单例，线程安全，也可防止反序列化攻击。

代码：

```Java
package com.turing.pattern;  
  
  
/**  
 * 枚举模式  
 * 反序列化，序列化输出后再输入，可通过添加readResolve()  
 * @author chiredeqiudong  
 * @date 2025/3/7  
 */
 public enum Singleton05 {  
  
    INSTANCE;  
  
    // 测试  
    public static void main(String[] args) {  
        for (int i = 0; i < 100; i++) {  
            new Thread(() -> {  
                System.out.println(Singleton05.INSTANCE.hashCode());  
            }).start();  
        }  
    }  
}
```

![](../images/Pasted%20image%2020250308003118.png)


如何确保全局唯一实例的创建？为什么线程安全？如何防止反射/反序列化攻击？

- [枚举实现单例模式的特点和优势](../文章转载/资料/枚举实现单例模式的特点和优势.md)

### 补充

反射机制破解单例模式（枚举除外）

```java
public class BreakSingleton{
    public static void main(String[] args) throw Exception{
        Class clazz = Class.forName("Singleton");
        Constructor c = clazz.getDeclaredConstructor(null);

        c.setAccessible(true);

        Singleton s1 = c.newInstance();
        Singleton s2 = c.newInstance();
        //通过反射，得到的两个不同对象
        System.out.println(s1);
        System.out.println(s2);
    }
}
```

避免此漏洞：

```Java
private Singleton() {
    //在构造器中加个逻辑判断,多次调用抛出异常
    if( instance != null){
        throw new RuntimeException()
    }
}
```


反序列化机制破解单例模式（枚举除外）：

```java
public class BreakSingleton{
	public static void main(String[] args) throws Exception{
	     //先根据单例模式创建对象(单例模式所以s1,s2是一样的)
	    Singleton s1=Singleton.getInstance();
	    Singleton s2=Singleton.getInstance();
		//将s1写入本地某个路径
	    FileOutputStream fos = new FileOutputStream("本地某个路径下文件");
	    ObjectOutputStream oos = new ObjectOutputStream(fos);
	    oos.writeObject(s1);
	    oos.close();
	    fos.close();

		//从本地某个路径读取写入的对象
	    ObjectInputStream ois=new ObjectInputStream(new FileInputStream("和上面的本地参数路径相同"));
	    Singleton s3=(Singleton) ois.readObject();
	    System.out.println(s1);
	    System.out.println(s2);
	    System.out.println(s3);//s3是一个新对象
	}
}
```

如何避免实现序列化单例模式的漏洞：

```java
public class Singleton implements Serializable{

	private static final Singleton singleton = new Singleton(); 

	private Singleton() {}
  
	public static Singleton getInstance(){
	  return singleton;
	}
  
	//反序列化定义该方法，则不需要创建新对象
	private Object readResolve() throws ObjectStreamException{
		return singleton;
	}
}
```

### 总结

单例模式的类**初始化规则**主要围绕如何确保**全局唯一实例的创建**、**线程安全**以及**防止反射/反序列化攻击**三个核心目标展开。

优缺点：

1. 单例模式提供了对唯一实例的受控访问。

2. 节约系统资源，对于一些需要频繁创建和销毁的对象单例模式无疑可以提高系统的性能。

3. 不利于扩展。

一般情况下，不建议使用懒汉方式，建议使用饿汉方式。只有在要明确实现 `lazy loading` 效果时，才会使用静态内部类（登记）方式。如果涉及到反序列化创建对象时，可以尝试使用枚举方式。如果有其他特殊的需求，可以考虑使用双检锁方式。

## 原型模式（Prototype Pattern）

>[五分钟学设计模式.17原型模式]( https://www.bilibili.com/video/BV1Tt4y1e7mk/?share_source=copy_web&vd_source=7341c7fca3b496e9108bb1fd49c634ef)

原型模式（Prototype Pattern）是用于*创建重复的对象*，同时又能保证性能。这种模式是实现了一个*原型接口*，该接口用于创建当前对象的**克隆**。当直接创建对象的代价比较大时，则采用这种模式。

简答的说，原型模式允许你通过**复制**已有的对象来创建新对象，而不需要重新创建对象的每个细节。

使用场景：一个对象需要在一个*高代价的数据库操作之后被创建*。我们可以缓存该对象，在下一个请求时返回它的**克隆**，在需要的时候更新数据库，以此来减少数据库调用。

结构：


![](../images/Pasted%20image%2020250309213757.png)


**Prototype接口** 继承`Cloneable`，定义了 `clone()` 方法，这是原型模式的核心。 所有需要被克隆的类都要实现这个接口。

```java
/**  
 * 1定义原型接口  
 */  
public interface Prototype extends Cloneable {  
          
	Prototype clone();  
  
    String getName();  
  
    void setName(String name);  
}
```

![](../images/Pasted%20image%2020250309213949.png)


**ConcretePrototype 类:** 实现了 `Prototype` 接口，并提供了具体的克隆逻辑。`super.clone()`方法执行的是浅拷贝。

```java
@Override  
public Prototype clone() {  
    try {  
        return (Prototype) super.clone(); // 浅拷贝  
    } catch (CloneNotSupportedException e) {  
        System.out.println("克隆失败");  
        return null;  
    }  
}
```

CloneNotSupportedException`: Java的 `clone()` 方法要求对象实现 `Cloneable` 接口，否则会抛出这个异常。

>**浅拷贝:** 只复制对象的基本类型属性和引用类型属性的 _引用_。 如果对象包含可变对象（比如List, Map, 其他自定义对象），克隆后的对象和原始对象会*共享*这些可变对象。 修改克隆对象中的可变对象也会影响原始对象。
>**深拷贝 (如果需要):** 如果需要深拷贝，你需要*手动复制*对象的所有属性，包括可变对象。 这通常涉及到递归调用克隆方法，或者使用序列化/反序列化等技术。


 创建一个原始对象，然后通过调用 `clone()` 方法创建它的副本。


![](../images/Pasted%20image%2020250309214159.png)

![](../images/Pasted%20image%2020250309214241.png)


为什么是原型对象自己克隆？

这是原型模式的核心设计思想之一。 让原型对象自己负责克隆，而不是由客户端或其他工厂类来完成，有以下几个优点：

- **封装性：** 对象自身最了解它的内部结构和状态。 让对象自己负责克隆，可以更好地封装克隆的细节，避免将这些细节暴露给客户端。

- **灵活性：** 不同的原型对象可能需要不同的克隆策略。 让对象自己实现 `clone()` 方法，可以根据自身的需求选择合适的克隆方式。 例如，某些对象可能只需要浅拷贝，而另一些对象可能需要深拷贝。

- **简化了客户端代码：** 隐藏了对象创建的细节，客户端不需要知道对象是如何创建的，客户端只需要调用 `clone()` 方法，就可以获得一个对象的副本。

- **动态地添加/删除产品：** 可以在运行时添加或删除原型对象

	- 为了实现动态添加/删除产品，原型模式通常会结合一个“原型管理器”或“原型注册表” (Prototype Manager/Registry) 来使用。 这个管理器/注册表实际上是一个存储原型对象的容器（例如，一个 `HashMap`）。

	- 对于需要克隆对象，我们现在这个管理器/注册表中获取到其实例，再进行克隆。

- **符合单一职责原则：** 对象只负责自身的克隆逻辑，而不需要承担其他职责。

原型模式的缺点：

- 克隆复杂对象可能比较困难，特别是当对象包含循环引用或者深层嵌套的对象时，*深拷贝*的实现会比较复杂。

- 需要实现 `Cloneable` 接口，Java的 `clone()` 方法有一些限制和问题（比如强制类型转换）。

# 结构型模式

结构型模式提供了一种*组织类和对象*的方法，该模式关注**对象之间的组合和关系**，旨在解决如何构建灵活且可复用的类和对象结构，以创建更大的、更灵活的系统。选择合适的结构型模式取决于具体的应用场景和需求。

## 适配器模式（Adapter Pattern）

>[五分钟学设计模式.06.适配器模式](https://www.bilibili.com/video/BV1Hz411e7sA/?share_source=copy_web&vd_source=7341c7fca3b496e9108bb1fd49c634ef)

适配器模式（Adapter Pattern）充当两个不兼容接口之间的桥梁。它通过一个中间件（适配器）将一个类的接口转换成客户期望的另一个接口，使原本不能一起工作的类能够协同工作。

结构：


![](../images/Pasted%20image%2020250309222321.png)



**现有接口 (Adaptee)：** `AdvancedMediaPlayer` 接口代表了现有的、但客户端无法直接使用的接口。 这里，它支持 `playVlc()` 和 `playMp4()` 两种方法。

```java
/**  
 * 1. 现有接口 (Adaptee)  
 */
 public interface AdvancedMediaPlayer {  
  
    void playVlc(String fileName);  
  
    void playMp4(String fileName);  
}
```


**现有接口的具体实现：** `VlcPlayer` 和 `Mp4Player` 是 `AdvancedMediaPlayer` 接口的具体实现类，分别负责播放 VLC 和 MP4 格式的音频。

```java
public class Mp4Player implements AdvancedMediaPlayer {  
    @Override  
    public void playVlc(String fileName) {  
        // 不做任何事情，因为Mp4Player不支持vlc  
    }  
  
    @Override  
    public void playMp4(String fileName) {  
        System.out.println("Playing mp4 file. Name: " + fileName);  
    }  
}


public class VlcPlayer implements AdvancedMediaPlayer {  
    @Override  
    public void playVlc(String fileName) {  
        System.out.println("Playing vlc file. Name: " + fileName);  
    }  
  
    @Override  
    public void playMp4(String fileName) {  
        // 不做任何事情，因为VlcPlayer不支持mp4  
    }  
}

```


**目标接口 (Target)：** `MediaPlayer` 接口代表了客户端*期望使用的接口*。 这里，它只有一个 `play()` 方法，可以根据音频类型播放不同格式的音频。

```java
/**  
 * 3. 目标接口 (Target)  
 * @author chiredeqiudong  
 * @date 2025/3/9  
 */
 public interface MediaPlayer {  
  
    void play(String audioType, String fileName);  
  
}
```


**适配器类 (Adapter)：** `MediaAdapter` 类实现了 `MediaPlayer` 接口，并且持有一个现有接口 `AdvancedMediaPlayer` 的引用。 它负责将客户端的请求适配到现有的 `AdvancedMediaPlayer` 实现类上。

```java
public class MediaAdapter implements MediaPlayer {  

	// 现有的播放接口
    AdvancedMediaPlayer advancedMusicPlayer;  
  
    public MediaAdapter(String audioType) {  
        if (audioType.equalsIgnoreCase("vlc")) {  
            advancedMusicPlayer = new VlcPlayer();  
        } else if (audioType.equalsIgnoreCase("mp4")) {  
            advancedMusicPlayer = new Mp4Player();  
        }  
    }  
  
    @Override  
    public void play(String audioType, String fileName) {  
        if (audioType.equalsIgnoreCase("vlc")) {  
            advancedMusicPlayer.playVlc(fileName);  
        } else if (audioType.equalsIgnoreCase("mp4")) {  
            advancedMusicPlayer.playMp4(fileName);  
        }  
    }  
}
```

- **构造函数：** 在构造函数中，根据音频类型选择合适的 `AdvancedMediaPlayer` 实现类。
- 在 `play()` 方法中，根据音频类型调用对应的 `AdvancedMediaPlayer` 方法。

**客户端代码：** 通过 `MediaAdapter` 类来播放不同格式的音频，而不需要直接使用 `AdvancedMediaPlayer` 接口。

```java
// 5. 客户端代码  
public class AdapterDemo {  
    public static void main(String[] args) {  
        MediaPlayer audioPlayer = new MediaAdapter("vlc");  
        audioPlayer.play("vlc", "beyond the sea.vlc");  
  
        MediaPlayer anotherAudioPlayer = new MediaAdapter("mp4");  
        anotherAudioPlayer.play("mp4", "alone.mp4");  
    }  
}
```

![](../images/Pasted%20image%2020250309223059.png)


**适配器模式的关键思想：**

适配器模式允许我们使用一个现有类，即使它的接口与你的代码期望的接口不兼容。 适配器模式的解决方法是通过创建一个适配器类，将现有类的接口转换为客户端期望的接口，从而实现接口的兼容（在适配器类中持有一个现有类的实例）。

**适配器模式的两种主要形式：**

- **对象适配器：** 像上面的例子一样，适配器类持有一个现有类的 _实例_，并通过调用该实例的方法来实现适配。

- **类适配器：** 适配器类 _继承_ 现有类和目标接口。 这种方式使用多重继承来实现适配。 但由于Java不支持多重继承，所以类适配器在Java中不太常用。

## 桥接模式（Bridge Pattern）

>[五分钟学设计模式.21.桥接模式](https://www.bilibili.com/video/BV1Pp4y167DG/?share_source=copy_web&vd_source=7341c7fca3b496e9108bb1fd49c634ef)

桥接（Bridge）是用于把*抽象化与实现化解耦*，使得二者可以独立变化。它避免了当你有多个独立的维度变化时，继承可能导致的“类爆炸”问题。

结构：


![](../images/Pasted%20image%2020250310151312.png)


如果我们新增一个绿色和三角形状，按照上述的设计，我们只需要新增2个类，但却可以应用 5 个变化。如下：


![](../images/Pasted%20image%2020250310152338.png)


如果没有桥接模式：

1. **直接组合形状和颜色:** 我们需要将它们直接组合在一起，为每种形状和颜色的组合创建了一个具体的类。例如`RedCircle`、`RedSquare`。类的数量将会变为`n（shape个数）x n（颜色种类）`
   
2. **类爆炸问题:** 如果我们添加新的形状（比如三角形）或新的颜色（比如绿色），就需要创建更多新的类：`RedTriangle`, `BlueTriangle`, `GreenCircle`, `GreenSquare`, `GreenTriangle` 等等。 不利于扩展。
   
3. **代码重复:** 每个类中的 `draw()` 方法，在形状部分的代码逻辑可能有很多重复，例如，绘制圆形的逻辑在 `RedCircle` 和 `BlueCircle` 中会重复，绘制正方形的逻辑在 `RedSquare` 和 `BlueSquare` 中会重复。 这违反了 "DRY" (Don't Repeat Yourself) 原则。


桥接模式，代码如下：

`Color`接口: 定义了颜色操作的接口，这里只有一个 `applyColor()` 方法。

```java
/**  
 * 定义颜色接口  
 * 颜色是形状的实现细节，可以独立变化。  
 */  
public interface Color {  
  
    void applyColor();  
}
```



`RedColor` 和 `BlueColor` 实现了 `Color` 接口，提供了具体的颜色应用逻辑。

```java
public class BlueColor implements Color {  
    @Override  
    public void applyColor() {  
        System.out.println("应用蓝色");  
    }  
}

public class RedColor implements Color {  
    @Override  
    public void applyColor() {  
        System.out.println("应用红色");  
    }  
}
```


`Shape` (抽象类) 定义了形状的抽象，持有一个 `Color` 接口的引用 `color`。 `draw()` 方法抽象的，由子类具体实现。

```java
public abstract class Shape {  
    // 桥接的核心：持有 Implementor 接口的引用  
    protected Color color;  
  
    // 构造函数接收 Implementor 接口的实例  
    protected Shape(Color color) {  
        this.color = color;  
    }  
  
    // 抽象方法，不同的形状会有不同的绘制逻辑  
    public abstract void draw();  
}
```

`Circle` 和 `Square` (Refined Abstractions) 继承了 `Shape`，实现了具体的形状绘制逻辑。关键是在 `draw()` 方法中调用 `color.applyColor()` 来应用颜色，形状的绘制和颜色的应用被**桥接**起来。

```java
public class Circle extends Shape {  
  
    public Circle(Color color) {  
        super(color);  
    }  
  
    @Override  
    public void draw() {  
        System.out.print("绘制圆形，");  
        // 调用 Implementor 的方法来应用颜色  
        color.applyColor();  
    }  
}

public class Square extends Shape {  
  
    public Square(Color color) {  
        super(color);  
    }  
  
    @Override  
    public void draw() {  
        System.out.print("绘制正方形，");  
        // 调用 Implementor 的方法来应用颜色  
        color.applyColor();  
    }  
}
```


`BridgePatternDemo` (客户端) 演示了如何使用桥接模式。可以看到，我们可以独立地创建颜色对象 ( `red`, `blue`) 和形状对象 (`redCircle`, `blueSquare`)，然后通过构造函数将颜色注入到形状中。 形状的实现和颜色的实现是解耦的，可以独立变化。

```java
public class BridgePatternDemo {  
    public static void main(String[] args) {  
        // 创建红色和蓝色的具体颜色实现  
        Color red = new RedColor();  
        Color blue = new BlueColor();  
        GreenColor green = new GreenColor();  
  
        // 创建红色圆形和蓝色正方形，形状和颜色解耦了  
        Shape redCircle = new Circle(red);  
        Shape blueSquare = new Square(blue);  
  
        // 创建红色三角和绿色三角  
        Triangle greenTriangle = new Triangle(green);  
        Triangle redTriangle = new Triangle(red);  
  
        // 绘制形状  
        redCircle.draw(); // 输出: 绘制圆形，应用红色  
        blueSquare.draw(); // 输出: 绘制正方形，应用蓝色  
        greenTriangle.draw(); // 输出: 绘制三角形，应用绿色  
        redTriangle.draw(); // 输出: 绘制三角形，应用红色  
    }  
}
```


桥接模式的核心思想：

1. **将抽象部分与它的实现部分分离，使它们都可以独立地进行变化。** 在上面的例子中，`Shape` (形状) 是抽象部分，`Color` (颜色) 是实现部分。

2. **使用组合/聚合关系来替代继承关系。** `Shape` 类持有一个 `Color` 接口的引用，而不是继承颜色。这样，形状的变化和颜色的变化就不会互相影响。

## 外观模式（Facade Pattern）

>[五分钟学设计模式.08.外观模式](https://www.bilibili.com/video/BV1xz4y1X7HW/?share_source=copy_web&vd_source=7341c7fca3b496e9108bb1fd49c634ef)

外观模式的主要目的是为复杂的子系统提供**一个简化的接口**，使得客户端更容易使用子系统。


![示例](../images/Pasted%20image%2020250317204019.png)


上图中，用户如果开启证明，需要在4个系统中分别得到证明。如果引入外观模式，如下图，只需要和“政务证明人”联系即可。


![](../images/Pasted%20image%2020250317204301.png)


结构：

```java
// 子系统1
class SubsystemA {
    void operationA() {
        System.out.println("Subsystem A operation");
    }
}

// 子系统2
class SubsystemB {
    void operationB() {
        System.out.println("Subsystem B operation");
    }
}

// 子系统3
class SubsystemC {
    void operationC() {
        System.out.println("Subsystem C operation");
    }
}

// 外观类
class Facade {
    private SubsystemA subsystemA;
    private SubsystemB subsystemB;
    private SubsystemC subsystemC;

    public Facade() {
        this.subsystemA = new SubsystemA();
        this.subsystemB = new SubsystemB();
        this.subsystemC = new SubsystemC();
    }

    public void operation() {
        System.out.println("Facade starts operations...");
        subsystemA.operationA();
        subsystemB.operationB();
        subsystemC.operationC();
        System.out.println("Facade ends operations...");
    }
}

// 客户端代码
public class FacadePatternDemo {
    public static void main(String[] args) {
        Facade facade = new Facade();
        facade.operation();
    }
}

```

主要的作用：

- 降低客户端与复杂子系统之间的耦合度。
- 简化客户端对复杂系统的操作，隐藏内部实现细节。

缺点也很明显，违背了开闭原则，如果新增一个子系统，就需要修改原代码。

## 代理模式（Proxy Pattern）

> [五分钟学设计模式.11.代理模式](https://www.bilibili.com/video/BV15V411z7nD/?share_source=copy_web&vd_source=7341c7fca3b496e9108bb1fd49c634ef)

代理模式（Proxy Pattern）是一种结构型设计模式，它的主要目的是为某个对象提供一个代理，以控制对该对象的访问。通过*代理对象*，可以在不修改*目标对象*的情况下，增加额外的功能或行为。

用途一，*控制对目标对象的访问*

- **权限控制** ：只有特定用户才能访问某些方法
- **延迟加载（Lazy Loading）** ：在需要时才创建或加载目标对象，从而节省资源
- **远程访问** ：当目标对象位于远程服务器上时，代理可以隐藏网络通信的细节

用途二，*增加额外的功能*，这种功能增强通常被称为“横切关注点”（Cross-Cutting Concerns）

- **日志记录** ：在方法调用前后记录日志
- **性能监控** ：测量方法的执行时间
- **事务管理** ：在数据库操作中自动开启、提交或回滚事务
- **缓存** ：在代理层实现缓存逻辑，避免重复计算或数据库查询

>[横切关注点](https://zh.wikipedia.org/wiki/%E6%A8%AA%E5%88%87%E5%85%B3%E6%B3%A8%E7%82%B9)

用途三，*隐藏复杂性*，将复杂的实现细节隐藏起来，只暴露简单的接口给客户端

- **远程代理** ：隐藏网络通信的复杂性，让客户端像调用本地对象一样调用远程对象
- **虚拟代理** ：隐藏大对象的创建过程，直到真正需要时才加载

代理模式的主要是实现方式：

1. **静态代理：** 代理类在编译时就已经确定。通常，代理类和目标类实现同一个接口
2. **动态代理：** 代理类在运行时动态生成，通常使用Java的反射机制

---

静态代理的 Demo：

```java
// 接口
public interface Service {
    void serve();
}

// 目标类
public class RealService implements Service {
    @Override
    public void serve() {
        System.out.println("Real service is being served.");
    }
}

// 代理类
public class ProxyService implements Service {
    private Service realService; // 代理的目标对象

    public ProxyService() {
        this.realService = new RealService();
    }

    @Override
    public void serve() {
        System.out.println("Logging: Before service");
        realService.serve();
        System.out.println("Logging: After service");
    }
}

// 客户端代码
public class Main {
    public static void main(String[] args) {
        Service service = new ProxyService();
        service.serve();
    }
}
```

运行结果：

```Java
Logging: Before service
Real service is being served.
Logging: After service
```

>代理模式的实现思路在其他模式中也都有体现，如装饰器模式、适配器模式等


**动态代理**是一种在*运行时动态生成代理类*的技术，通常用于实现 AOP（如日志记录、权限检查、事务管理等），而无需修改业务逻辑代码。

通过 `java.lang.reflect.Proxy` 和 `InvocationHandler` 来实现：

```java
import java.lang.reflect.*;

interface Service {
    void serve();
}

class RealService implements Service {
    @Override
    public void serve() {
        System.out.println("Real service is being served.");
    }
}

// 拦截代理对象上的方法调用
class ProxyHandler implements InvocationHandler {
    private Object target;

    public ProxyHandler(Object target) {
        this.target = target;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println("Logging: Before service");
        Object result = method.invoke(target, args);  // 调用真实对象的方法
        System.out.println("Logging: After service");
        return result;
    }
}

// 客户端代码
public class Main {
    public static void main(String[] args) {
        // 创建真实对象
        RealService realService = new RealService();
        // 创建代理对象
        Service proxyService = (Service) Proxy.newProxyInstance(
            realService.getClass().getClassLoader(),
            realService.getClass().getInterfaces(),
            new ProxyHandler(realService)
        )
        // 使用代理对象调用方法
        proxyService.serve();
    }
}
```

运行结果：

```java
Logging: Before service
Real service is being served.
Logging: After service
```

相关技术解释：

- `Proxy.newProxyInstance()`动态代理的核心方法，用于在运行时创建一个代理对象
	- `ClassLoader` 目标对象的类加载器
	- `interfaces` 接口数组，代理类将实现 `realService` 所实现的所有接口
	- `InvocationHandler` 定义代理对象的行为
- `ProxyHandler` 的作用
	- 拦截代理对象上的方法调用，并在调用前后添加额外的逻辑，如日志记录、权限校验等
	- 具体行为在 `invoke()` 方法中定义
- 基于反射

>动态代理基于 Java 的反射机制，通过 `Proxy` 和 `InvocationHandler` 实现对目标对象方法的拦截和增强
>反射提供了运行时动态获取类和方法信息的能力，使得动态代理能够灵活地应用于各种场景如 AOP、远程调用等
>反射的性能开销和复杂性也需要在实际开发中加以权衡


代理模式的缺点

- **性能开销** ：代理对象会增加一层间接调用，可能会带来一定的性能损耗
- **复杂性增加** ：引入代理后，系统的结构变得更加复杂，可能增加理解和维护的难度
- **调试困难** ：由于方法调用被代理拦截，调试时可能难以追踪实际的执行路径

# 行为型模式

该类模式关注对象之间的通信和交互，旨在解决对象之间的责任分配和算法的封装。

## 责任链模式（Chain of Responsibility Pattern）

>[五分钟学设计模式.12.责任链模式](https://www.bilibili.com/video/BV1uk4y127hG/?share_source=copy_web&vd_source=7341c7fca3b496e9108bb1fd49c634ef)

![](images/Pasted%20image%2020250418132657.png)

责任链模式是一种行为型设计模式，它通过*将多个对象连接成一条链*，并沿着这条链传递请求，直到有一个对象能够处理该请求为止。这种模式的核心思想是*解耦请求的发送者和接收者*，将请求的处理逻辑分布到多个对象中，形成一个职责分明的处理链条 。

在责任链模式中，每个节点（处理器）都包含对下一个节点的引用，当一个请求到达时，当前节点可以选择处理该请求，或者将请求传递给下一个节点。这种机制使得请求的处理过程更加灵活和可扩展 。

责任链模式的主要用途：

1. **解耦请求发送者和接收者**  
	- 责任链模式将请求的发送者与具体的接收者解耦。发送者只需将请求发送到链的起点，而无需知道具体由哪个接收者处理请求 。
2. **动态分配责任**  
	- 通过责任链，可以*动态*地决定哪些对象负责处理请求。这种灵活性使得系统能够根据运行时的条件调整处理流程 
3. **简化复杂逻辑**  
	- 当一个请求需要经过多个步骤或条件判断时，责任链模式可以将这些逻辑分散到不同的处理器中，从而避免单一类承担过多的责任 

典型应用场景：

- 事件分发：在 GUI 框架中，事件可以沿着组件树向上冒泡，直到某个父组件处理它
- 日志记录：不同级别的日志处理器（如 DEBUG、INFO、ERROR）可以组成一条链，按需处理日志信息
- 在 Java Web 开发中责任链模式有广泛应用，如*过滤器链、拦截器*等。
- 审批流程：在企业系统中，审批请求可以依次经过多个角色如员工、经理、总监，直到某一级别完成审批

>GUI 是 Graphical User Interface 的缩写，称为图形用户界面

以下是一个简单的 Java 示例，展示如何使用责任链模式实现一个*审批流程*：

```java
// 定义请求类
class Request {
    private String content;
    private int level; // 请求的级别

    public Request(String content, int level) {
        this.content = content;
        this.level = level;
    }

    public int getLevel() {
        return level;
    }

    public String getContent() {
        return content;
    }
}

// 定义处理器抽象类
abstract class Handler {
    protected Handler nextHandler; // 下一个处理器

    public void setNextHandler(Handler nextHandler) {
        this.nextHandler = nextHandler;
    }
    // 抽象方法-出路请求
    public abstract void handleRequest(Request request);
}

// 具体处理器：员工处理器
class EmployeeHandler extends Handler {
    @Override
    public void handleRequest(Request request) {
        if (request.getLevel() <= 1) { // 员工只能处理低级别的请求
            System.out.println("员工处理了请求: " + request.getContent());
        } else if (nextHandler != null) {
            nextHandler.handleRequest(request); // 转发给下一个处理器
        }
    }
}

// 具体处理器：经理处理器
class ManagerHandler extends Handler {
    @Override
    public void handleRequest(Request request) {
        if (request.getLevel() <= 2) { // 经理可以处理中级别的请求
            System.out.println("经理处理了请求: " + request.getContent());
        } else if (nextHandler != null) {
            nextHandler.handleRequest(request); // 转发给下一个处理器
        }
    }
}

// 具体处理器：总监处理器
class DirectorHandler extends Handler {
    @Override
    public void handleRequest(Request request) {
        if (request.getLevel() <= 3) { // 总监可以处理高级别的请求
            System.out.println("总监处理了请求: " + request.getContent());
        } else {
            System.out.println("请求无法处理: " + request.getContent());
        }
    }
}

// 测试代码
public class ChainOfResponsibilityDemo {
    public static void main(String[] args) {
        // 创建处理器链
        Handler employee = new EmployeeHandler();
        Handler manager = new ManagerHandler();
        Handler director = new DirectorHandler();

        employee.setNextHandler(manager);
        manager.setNextHandler(director);

        // 创建请求并发送
        Request request1 = new Request("普通任务", 1);
        Request request2 = new Request("重要任务", 2);
        Request request3 = new Request("紧急任务", 3);
        Request request4 = new Request("超高级任务", 4);

        employee.handleRequest(request1); // 员工处理
        employee.handleRequest(request2); // 经理处理
        employee.handleRequest(request3); // 总监处理
        employee.handleRequest(request4); // 无法处理
    }
}
```

输出结果：

```java
员工处理了请求: 普通任务
经理处理了请求: 重要任务
总监处理了请求: 紧急任务
请求无法处理: 超高级任务
```

上述责任链中的角色：

- **抽象处理者（Handler）:**
    - 定义一个处理请求的接口，通常包含一个处理请求的方法（如 `handleRequest`）和一个指向下一个处理者的引用（后继者）
- **具体处理者（ConcreteHandler）:**
    - 实现了抽象处理者接口，负责处理请求。如果能够处理该请求，则直接处理；否则，将请求传递给下一个处理者
- **客户端（Client）:**
    - 创建处理者对象，并将它们连接成一条责任链。通常，客户端只需要将请求发送给责任链的第一个处理者，无需关心请求的具体处理过程


优点：

1. **降低耦合度**：发送者和接收者之间解耦
2. **简化对象**：对象不需要知道链的结构
3. **灵活性**：通过改变链的成员或顺序，动态地新增或删除责任，符合开闭原则
4. **易于扩展**：增加新的请求处理类很方便

缺点：

1. **请求未被处理**：不能保证请求一定会被链中的某个处理者接收
2. **性能影响**：可能影响系统性能，且调试困难，可能导致循环调用
3. **难以观察**：运行时特征不明显，可能妨碍除错

## 模板模式（Template Pattern）

>[五分钟学设计模式.13.模板方法模式](https://www.bilibili.com/video/BV1kk4y117j5/?share_source=copy_web&vd_source=7341c7fca3b496e9108bb1fd49c634ef)

![](images/Pasted%20image%2020250418204601.png)


**模板模式（Template Pattern）** 是一种行为型设计模式，它定义了一个操作中的算法骨架，而将一些步骤的实现延迟到子类中。模板模式使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。

简单来说，模板模式的核心思想是：**父类定义算法的整体流程，子类实现具体的细节**。这种模式通过抽象类或接口提供一个“模板方法”，该方法定义了算法的执行顺序，而具体的实现细节则由子类完成。

主要作用：

1. **代码复用**  
	1. 模板模式将公共的流程抽象到父类中，避免了重复代码。子类只需实现特定的逻辑，从而提高了代码的复用性
2. **扩展性**  
	1. 模板模式允许在不修改现有代码的情况下，通过新增子类来扩展功能，符合开闭原则
3. **流程控制**  
	1. 模板模式通过*父类的模板方法*控制算法的执行流程，确保整体逻辑的一致性，同时允许子类灵活地实现细节

以下是一个简单的 Java 示例，展示如何使用模板模式实现*制作饮料*的过程：

```java
// 抽象类：定义制作饮料的模板方法
abstract class Beverage {

    // 模板方法：定义制作饮料的整体流程
    public final void prepareBeverage() {
        boilWater();          // 烧水（通用步骤）
        brew();               // 冲泡（子类实现）
        pourInCup();          // 倒入杯中（通用步骤）
        if (customerWantsCondiments()) { // 钩子方法：是否需要调料
            addCondiments();   // 添加调料（子类实现）
        }
    }

    // 具体方法：烧水
    private void boilWater() {
        System.out.println("烧开水...");
    }

    // 抽象方法：冲泡（子类实现）
    protected abstract void brew();

    // 具体方法：倒入杯中
    private void pourInCup() {
        System.out.println("将饮料倒入杯中...");
    }

    // 抽象方法：添加调料（子类实现）
    protected abstract void addCondiments();

    // 钩子方法：默认返回 true，子类可覆盖
    protected boolean customerWantsCondiments() {
        return true;
    }
}

// 具体子类：制作咖啡
class Coffee extends Beverage {
    @Override
    protected void brew() {
        System.out.println("用热水冲泡咖啡...");
    }

    @Override
    protected void addCondiments() {
        System.out.println("加入糖和牛奶...");
    }

    @Override
    protected boolean customerWantsCondiments() {
        return false; // 客户不需要调料
    }
}

// 具体子类：制作茶
class Tea extends Beverage {
    @Override
    protected void brew() {
        System.out.println("用热水浸泡茶叶...");
    }

    @Override
    protected void addCondiments() {
        System.out.println("加入柠檬...");
    }
}

// 测试代码
public class TemplatePatternDemo {
    public static void main(String[] args) {
        Beverage coffee = new Coffee();
        System.out.println("制作咖啡:");
        coffee.prepareBeverage();

        Beverage tea = new Tea();
        System.out.println("制作茶:");
        tea.prepareBeverage();
    }
}
```

输出结果：

```java
制作咖啡:
烧开水...
用热水冲泡咖啡...
将饮料倒入杯中...

制作茶:
烧开水...
用热水浸泡茶叶...
将饮料倒入杯中...
加入柠檬...
```

主要角色：

1. **抽象类**中定义了一个或多个抽象方法（具体实现由子类完成），以及一个模板方法，通常是 `final` 的，防止子类覆盖）。模板方法负责调用这些抽象方法，从而定义算法的整体流程 
2. **具体子类**继承抽象类，并实现其中的抽象方法，提供具体的逻辑。子类无法改变模板方法的执行顺序，但可以自定义某些步骤的实现
3. **钩子方法**是一种默认实现的方法，子类可以*选择性*地覆盖它们，以进一步定制算法的行为

优点：

1. **提高代码复用性**：模板模式将*公共的流程*抽象到父类中，子类只需实现特定的逻辑，减少了重复代码
2. **增强扩展性**：新增功能时，只需创建新的子类并实现相应的抽象方法，无需修改现有代码，符合开闭原则 
3. **流程一致性**：模板方法确保了算法的整体流程不会被改变，从而保证了系统的稳定性和一致性
4. **灵活性**：钩子方法提供了额外的扩展点，允许子类根据需求定制算法的行为

缺点：

1. **类数量增加**：每个具体实现都需要一个子类，可能导致类的数量增多，增加了系统的复杂性
2. **调试困难**：由于算法的逻辑分布在父类和子类中，调试时可能难以追踪具体的执行路径
3. **过度设计**：对于简单的场景，使用模板模式可能会显得过于复杂，增加不必要的开销

## 策略模式（Strategy Pattern）

>[五分钟学设计模式.10.策略模式](https://www.bilibili.com/video/BV1vT4y1E7g6/?share_source=copy_web&vd_source=7341c7fca3b496e9108bb1fd49c634ef)

![](images/Pasted%20image%2020250418210540.png)


**策略模式（Strategy Pattern）** 是一种行为型设计模式，它*定义了一系列算法*，并将每个算法封装到独立的类中，使它们可以互相替换 。策略模式让算法独立于使用它的客户而变化，从而提高了代码的灵活性和可扩展性 。

简单来说，策略模式的核心思想是：**将一组相关的算法封装起来，使得它们可以互换使用**。这种模式允许在运行时根据不同的场景或需求选择合适的算法，而无需修改客户端代码 。

主要作用：

1. **解耦算法与客户端**：策略模式将算法的实现与使用分离，使得客户端无需关心算法的具体实现细节，只需通过策略接口与算法交互
2. **支持动态切换算法**：策略模式允许在运行时动态地选择或切换算法，从而适应不同的业务需求
3. **提高代码复用性**：每个具体策略类专注于实现特定的算法，避免了重复代码，同时便于复用和维护
4. **符合开闭原则**：新增算法时，只需添加新的具体策略类，无需修改现有代码

以下是一个简单的 Java 示例，展示如何使用策略模式实现不同的*支付方式*：

```java
// 策略接口：定义支付行为
interface PaymentStrategy {
    void pay(double amount);
}

// 具体策略：信用卡支付
class CreditCardPayment implements PaymentStrategy {
    private String cardNumber;

    public CreditCardPayment(String cardNumber) {
        this.cardNumber = cardNumber;
    }

    @Override
    public void pay(double amount) {
        System.out.println("使用信用卡支付: $" + amount + " (卡号: " + cardNumber + ")");
    }
}

// 具体策略：PayPal 支付
class PayPalPayment implements PaymentStrategy {
    private String email;

    public PayPalPayment(String email) {
        this.email = email;
    }

    @Override
    public void pay(double amount) {
        System.out.println("使用 PayPal 支付: $" + amount + " (邮箱: " + email + ")");
    }
}

// 上下文类：维护对策略的引用
class ShoppingCart {
    private PaymentStrategy paymentStrategy;

    // 设置支付策略
    public void setPaymentStrategy(PaymentStrategy paymentStrategy) {
        this.paymentStrategy = paymentStrategy;
    }

    // 执行支付
    public void checkout(double amount) {
        if (paymentStrategy == null) {
            throw new IllegalStateException("未设置支付策略");
        }
        paymentStrategy.pay(amount);
    }
}

// 客户端
public class StrategyPatternDemo {
    public static void main(String[] args) {
        // 创建购物车
        ShoppingCart cart = new ShoppingCart();

        // 使用信用卡支付
        cart.setPaymentStrategy(new CreditCardPayment("1234-5678-9012-3456"));
        cart.checkout(100.0);

        // 使用 PayPal 支付
        cart.setPaymentStrategy(new PayPalPayment("user@example.com"));
        cart.checkout(200.0);
    }
}
```

输出结果：

```Java
使用信用卡支付: $100.0 (卡号: 1234-5678-9012-3456)
使用 PayPal 支付: $200.0 (邮箱: user@example.com)
```

主要的角色：

1. **上下文（Context）**：上下文类维护一个*对策略接口的引用*，并通过该引用来调用具体的策略实现。上下文类通常负责接收客户端请求，并将请求委托给当前策略对象处理
2. **策略接口（Strategy）**：策略接口定义了所有具体策略类需要实现的通用方法。这些方法代表了算法的行为或逻辑
3. **具体策略（Concrete Strategy）**：具体策略类实现了策略接口，提供具体的算法实现。每种策略对应一种算法或行为

优点：

1. **提高代码的灵活性**：策略模式允许在运行时动态切换算法，从而适应不同的业务需求
2. **解耦算法与客户端**：客户端只需依赖策略接口，而无需关心具体的算法实现，降低了耦合
3. **增强代码的可扩展性**：新增算法时，只需添加新的具体策略类，无需修改现有代码，符合 OCP

缺点：

1. **增加类的数量**：每种策略都需要一个具体策略类，可能导致类的数量增多，增加了系统的复杂性
2. **客户端需要了解不同策略**：客户端需要知道有哪些策略可供选择，并手动设置具体的策略对象，这可能会增加客户端的负担
3. **不适合简单场景**：对于只有少数几种固定算法的简单场景，使用策略模式可能会显得过于复杂，增加不必要的开销

## 观察者模式（Observer Pattern）

>[五分钟学设计模式.07.观察者模式](https://www.bilibili.com/video/BV1vg4y1v7V4/?share_source=copy_web&vd_source=7341c7fca3b496e9108bb1fd49c634ef)

![](images/Pasted%20image%2020250418212100.png)


**观察者模式（Observer Pattern）** 是一种行为型设计模式，它定义了对象之间的一种*一对多的依赖关系*，使得每当一个对象的状态发生改变时，所有依赖于它的对象都会得到*通知*并自动更新 。这种模式也被称为*发布-订阅模式（Publish/Subscribe）*，因为主题（Subject）负责发布状态变化，而观察者（Observer）负责订阅这些变化。

简单来说，观察者模式的核心思想是：**一个目标对象管理多个观察者对象，并在自身状态发生变化时主动通知这些观察者** 。

作用：

1. **解耦对象之间的依赖**：观察者模式将主题与观察者解耦，使得它们可以独立变化，从而提高了系统的灵活性和可维护性
2. **支持广播通信**：主题可以通过通知机制向多个观察者*广播*状态变化，而无需直接调用每个观察者的方法
3. **动态订阅与取消订阅**：观察者可以在运行时动态地订阅或取消订阅主题，从而适应不同的业务需求
4. **适用于事件驱动系统**：观察者模式非常适合用于事件驱动的场景，例如 GUI 框架中的事件处理、消息队列等

以下是一个简单的 Java 示例，展示如何使用观察者模式实现*天气数据的更新和通知*：

```java
import java.util.ArrayList;
import java.util.List;

// 抽象观察者接口
interface Observer {
    void update(float temperature, float humidity, float pressure);
}

// 抽象主题接口
interface Subject {
    void registerObserver(Observer observer); // add
    void removeObserver(Observer observer); // remove
    void notifyObservers(); // notify
}

// 具体主题：天气数据
class WeatherData implements Subject {
    private List<Observer> observers;
    private float temperature;
    private float humidity;
    private float pressure;

    public WeatherData() {
        observers = new ArrayList<>();
    }

    @Override
    public void registerObserver(Observer observer) {
        observers.add(observer);
    }

    @Override
    public void removeObserver(Observer observer) {
        observers.remove(observer);
    }

    @Override
    public void notifyObservers() {
        for (Observer observer : observers) {
            observer.update(temperature, humidity, pressure);
        }
    }

    // 更新天气数据并通知观察者
    public void setMeasurements(float temperature, float humidity, float pressure) {
        this.temperature = temperature;
        this.humidity = humidity;
        this.pressure = pressure;
        notifyObservers();
    }
}

// 具体观察者：当前条件显示
class CurrentConditionsDisplay implements Observer {
    private float temperature;
    private float humidity;

    @Override
    public void update(float temperature, float humidity, float pressure) {
        this.temperature = temperature;
        this.humidity = humidity;
        display();
    }

    public void display() {
        System.out.println("Current conditions: " + temperature + "F degrees and " + humidity + "% humidity");
    }
}

// 测试代码
public class ObserverPatternDemo {
    public static void main(String[] args) {
        // 创建主题和观察者
        WeatherData weatherData = new WeatherData();
        CurrentConditionsDisplay currentDisplay = new CurrentConditionsDisplay();

        // 注册观察者
        weatherData.registerObserver(currentDisplay);

        // 更新天气数据
        weatherData.setMeasurements(80, 65, 30.4f);
        weatherData.setMeasurements(82, 70, 29.2f);
        weatherData.setMeasurements(78, 90, 29.2f);
    }
}
```

输出结果：

```Java
Current conditions: 80.0F degrees and 65.0% humidity
Current conditions: 82.0F degrees and 70.0% humidity
Current conditions: 78.0F degrees and 90.0% humidity
```

主要角色：

1. **主题（Subject）**：主题是*被观察的对象*，它维护了一个*观察者列表*，并提供了添加、删除和通知观察者的接口。主题会在其状态发生变化时通知所有注册的观察者
2. **观察者（Observer）**：观察者是一个抽象类或接口，定义了一个更新方法，如 `update()`，用于接收主题的通知并作出反应
3. **具体主题（Concrete Subject）**：具体主题实现了主题接口，负责管理自身的状态，并在状态变化时通知观察者
4. **具体观察者（Concrete Observer）**：具体观察者实现了观察者接口，定义了在接收到通知时的具体行为

优点：

1. **支持松散耦合**：主题与观察者之间通过抽象接口进行交互，降低了它们之间的耦合性，使得两者可以独立变化
2. **支持广播通信**：主题可以通过通知机制向多个观察者广播状态变化，而无需逐个调用观察者的方法
3. **增强扩展性**：新增观察者时，只需实现观察者接口并注册到主题中，无需修改现有代码，符合开闭原则
4. **适用于事件驱动系统**：观察者模式非常适合用于事件驱动的场景，例如 GUI 框架中的事件处理、消息队列等

缺点：

1. **通知顺序难以控制**：如果观察者的更新逻辑依赖于特定的执行顺序，可能会导致问题，因为通知通常是以无序的方式进行的
2. **性能问题**：如果观察者数量较多，或者通知逻辑较为复杂，可能会导致性能下降
3. **循环依赖风险**：如果主题和观察者之间存在循环依赖，可能会导致系统崩溃或无限循环
4. **调试困难**：由于通知机制的动态性，调试时可能难以追踪具体的执行路径

## 行为型模式总结

行为型模式（Behavioral Pattern）是设计模式的一种类型，主要关注**对象之间的责任划分和交互方式**。它不仅定义了**对象的结构**，还重点描述了**对象之间的通信和协作机制** 。通过行为型模式，可以增强系统的灵活性和可扩展性，同时降低对象之间的耦合度。

行为型模式分为两类：

- **类行为模式**：采用继承机制在类之间分配行为。这种方式的耦合度较高，通常较少使用
- **对象行为模式**：采用组合或聚合的方式在对象之间分配行为。由于组合或聚合的耦合度较低，因此更符合“合成复用原则” 

行为模式的普遍优点：

1. **降低耦合度**：行为型模式通过*抽象接口或中间层*减少了对象之间的直接依赖，从而提高了系统的灵活性
2. **增强扩展性**：新增功能时，可以通过添加新的类或对象来实现，而无需修改现有代码，符合开闭原则
3. **提高代码复用性**：行为型模式将通用的行为抽象出来，避免了重复代码，使得代码更容易复用和维护
4. **支持动态行为**：行为型模式允许在运行时动态地切换算法、状态或策略，从而适应不同的业务需求

行为模式的普遍缺点：

1. **复杂性增加**：行为型模式引入了额外的类和接口，可能会增加系统的复杂性，尤其在简单场景下可能显得过度设计
2. **调试困难**：由于对象之间的交互分散在多个类中，调试时可能难以追踪具体的执行路径
3. **性能问题**：某些行为型模式（如观察者模式）可能导致性能下降，尤其是在观察者数量较多或通知逻辑复杂的情况下

# 参考资料

【菜鸟教程】https://www.runoob.com/design-pattern/design-pattern-tutorial.html
【CodingBetterlife】[CodingBetterlife - "成为架构师"-微信公众号系列文章](https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzkzMDI0ODg4NQ==&action=getalbum&album_id=2247053463681564673&scene=126&sessionid=-1538859753#wechat_redirect)
【哔哩哔哩 程序员一棵树】[设计模式](https://space.bilibili.com/354804345/search?keyword=设计模式)
【哔哩哔哩 子烁爱学习】[设计模式](https://space.bilibili.com/59546029/search?keyword=设计模式)

