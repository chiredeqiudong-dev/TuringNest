---
title: Leetcode Hot-100 题解
slug: leetcode-hot100
date: 2025-08-10
categories: 算法
tags:
  - leetcode
  - hot-100
---
# 哈希
### [两数之和](https://leetcode.cn/problems/two-sum/)

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        HashMap<Integer,Integer> map = new HashMap<>();
        for(int i = 0; i < nums.length; i ++){
            int a = nums[i];
            if(map.containsKey(target - a)){
                return new int[] {i,map.get(target - a)};
            }
            map.put(a,i);
        }
        return null;
    }
}
```

-  $a + b = c$ 题目类型，因为 $b = c - a$，所以遍历 a，查询 b 即可。
- 使用哈希表以 $O(1)$ 复杂度查询。
### [字母异位词分组](https://leetcode.cn/problems/group-anagrams/)

```java
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        HashMap<String, List<String>> hashMap = new HashMap<>();
        for (String str : strs) {
            // 转为字符数组排序
            char[] array = str.toCharArray();
            Arrays.sort(array);
            // 转为String为key，做判断
            String key = Arrays.toString(array);
            // 判断是否存在该单词
            List<String> ans = hashMap.getOrDefault(key, new ArrayList<>());
            ans.add(str);
            hashMap.put(key,ans);
        }
        // 结果集
        return new ArrayList<List<String>>(hashMap.values());
    }
}
```

- 将字符串排序后作为 key，从而得到字母异位词分组
- `Collection<T> values = hashMap.values()`，`list.addAll(Collection<? extends E> c)`
### [最长连续序列](https://leetcode.cn/problems/longest-consecutive-sequence/)

```java
class Solution {
    public int longestConsecutive(int[] nums) {
        Set<Integer> set = new HashSet<>();
        // 去重
        for(int num : nums){
            set.add(num);
        }
        int maxL = 0;
        //x-1 的序列长度 >> x 的序列长度
        for(int x : set){
            if(set.contains(x - 1)){
                continue;
            }else{
                int curL = 1;
                while(set.contains(x + 1)){
                    curL ++;
                    x ++;
                }
                maxL = Math.max(maxL,curL);
            }
        }
        return maxL;
    }
}
```

- [题解](https://leetcode.cn/problems/longest-consecutive-sequence/solutions/3005726/ha-xi-biao-on-zuo-fa-pythonjavacgojsrust-whop/?envType=study-plan-v2&envId=top-100-liked)
- 哈希去重，如果哈希表存在 x - 1，那么以 x - 1 开始的数字序列长度一定大于 x。
# 双指针
### [移动零](https://leetcode.cn/problems/move-zeroes/)

```java
class Solution {
    public void moveZeroes(int[] nums) {
        int head = 0;
        int tail = 0;
        // 将不为0的num[tail]依次插入num[head]
        while (tail < nums.length) {
            if (nums[tail] != 0) {
                int temp = nums[head];
                nums[head] = nums[tail];
                nums[tail] = temp;
                head++;
            }
            tail ++;
        }
    }
}
```

- 参考栈的设计，不为 0 的元素依次入栈
### [盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/)

```java
class Solution {
    public int maxArea(int[] height) {
        int left = 0;
        int right = height.length - 1;
        int area = -1;
        while(left < right) {
            area = Math.max(area,(right - left) * Math.min(height[left],height[right]));
            // 移动短板
            if(height[left] >= height[right]){
                right --;
            }else{
                left ++;
            }
        }
        return area;
    }
}
```

- [题解](https://leetcode.cn/problems/container-with-most-water/solutions/11491/container-with-most-water-shuang-zhi-zhen-fa-yi-do/?envType=study-plan-v2&envId=top-100-liked)
- 若向内**移动短板**，水槽的短板`min(h[left],h[right])`可能变大，因此下个水槽的面积**可能增大**。
- 若向内**移动长板**，水槽的短板`min(h[left],h[right])`不变或变小，因此下个水槽的面积**一定变小**。
### [三数之和](https://leetcode.cn/problems/3sum/)

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        List<List<Integer>> res = new ArrayList<>();
        // a + b + c = sum
        for(int i = 0; i < nums.length - 2; i++) {
            int a = nums[i];
            // 去重
            if(i > 0 && nums[i] == nums[i - 1]) continue;
            // 双指针枚举[i + 1, nums.length]中元素
            int l = i + 1;
            int r = nums.length - 1;
            while(l < r){
                int sum = a + nums[l] + nums[r];
                if(sum > 0){
                    while(l < r && nums[r] == nums[--r]);
                }else if(sum < 0) {
                    while(l < r && nums[l] == nums[++l]);
                }else{
                    List<Integer> ans = new ArrayList<>();
                    ans.add(a);
                    ans.add(nums[l]);
                    ans.add(nums[r]);
                    res.add(ans);
                    // 去重
                    while(l < r && nums[r] == nums[--r]);
                    while(l < r && nums[l] == nums[++l]);
                }
            }
        }
        return res;
    }
}
```

- [题解](https://leetcode.cn/problems/3sum/solutions/11525/3sumpai-xu-shuang-zhi-zhen-yi-dong-by-jyd/?envType=study-plan-v2&envId=top-100-liked)
- 双指针 l , r 交替向中间移动，记录 `nums[i] + nums[l] + nums[r] == 0` 的 l , r 组合。
- 通过排序，$a+b+c=sum$ 中，sum 的值可以通过移动 l , r 指针控制。
- 排序后，`nums[i-1]`得到的`(i-1,l,r)`结果一定包含了`nums[i]`的结果，从而解决重复。
### [接雨水](https://leetcode.cn/problems/trapping-rain-water/)

```java
class Solution {
    public int trap(int[] height) {
        // maxL[i]为左边柱子的最大高度，包括本身
        int[] maxL = new int[height.length]; 
        // maxL[i]为右边柱子的最大高度，包括本身
        int[] maxR = new int[height.length]; 
        maxL[0] = height[0];
        maxR[height.length - 1] = height[height.length - 1];
        for (int i = 1; i < height.length; i++) {
            maxL[i] = Math.max(maxL[i - 1], height[i]);
        }
        for (int i = height.length - 2; i >= 0; i --) {
            maxR[i] = Math.max(maxR[i + 1], height[i]);
        }
        // 接的雨水为当前柱子i Min{maxL[i],maxR[i]} - height[i]
        int cnt = 0;
        for(int i = 1; i < height.length - 1; i++) {
            int res = Math.min(maxL[i - 1],maxR[i + 1]) - height[i];
            cnt += Math.max(res, 0);
        }
        return cnt;
    }
}
```

- [题解](https://leetcode.cn/problems/trapping-rain-water/solutions/692342/jie-yu-shui-by-leetcode-solution-tuvc/)
- 木桶理论，dp 的代码更好理解。
- 对于每一列可以接的雨水取决于左右两边最高的短木板减去当前木板高度（如下图所示）。

![](https://cdn.img.turingzy.cn/2025/Hot-100-0811.webp)
# 滑动窗口
### [无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        if(s.length() <= 0) return 0;
        char[] arr = s.toCharArray();
        Set<Character> set = new HashSet<>();
        int head = 0;
        int tail = 1;
        set.add(arr[0]);
        int res = 1;
        while(tail < arr.length){
            // 伸缩
            while(head < tail && set.contains(arr[tail])) {
                set.remove(arr[head]);
                head ++;
            }
            // 扩张
            set.add(arr[tail]);
            res = Math.max(res,tail - head + 1);
            tail ++;
        }
        return res;
    }
}
```

- 不定长滑动窗口
- 通过哈希表去重
### [找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/)

```java
class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        if(s.length() < p.length()) return new ArrayList<>();
        int[] base = new int[26];
        for(char c: p.toCharArray()) {
            base[c - 'a'] ++;
        }
        int[] cnt = new int[26];
        for(int i = 0; i < p.length(); i++){
            cnt[s.charAt(i) - 'a'] ++;
        }
        int l = 0;
        int r = p.length() - 1;
        List<Integer> res = new ArrayList<>();
        while(r < s.length()){
            if(Arrays.equals(cnt,base)){
                res.add(l);
            }
            // 防止越界
            if(r == s.length() - 1){
                break;
            }
            cnt[s.charAt(l++) - 'a'] --;
            cnt[s.charAt(++r) - 'a'] ++;
        }
        return res;
    }
}
```

- 定长滑动窗口
- 通过`Arrays.equals()`来比较两个数组的值是否相等（只包含小写字母，比较耗时可忽略）。
- 因为是先定好了窗口（第二个 for 循环）才开始比较，所以需要注意是否索引越界。
# 字串
### [和为 K 的子数组](https://leetcode.cn/problems/subarray-sum-equals-k/)

```java
// 解法一: 直接枚举所有子数组
class Solution {
    public int subarraySum(int[] nums, int k) {
        int res = 0;
        for (int i = 0; i < nums.length; i++) {
            int ans = 0;
            for (int j = i; j < nums.length; j++) {
                ans += nums[j];
                if (ans == k) {
                    res ++;
                }
            }
        }
        return res;
    }
}
// 解法二：动态规划
class Solution {
    public int subarraySum(int[] nums, int k) {
        HashMap<Integer, Integer> mp = new HashMap<>();
        // suf: 表示
        int res = 0;
        int suf = 0;
        // 当suf[i] - k = 0 即suf[i] = k时的初始值
        mp.put(0, 1); 
        for (int i = nums.length - 1; i >= 0; i--) {
            suf+=nums[i];
            if (mp.containsKey(suf - k)) {
                res += mp.get(suf - k);
            }
            mp.put(suf, mp.getOrDefault(suf, 0) + 1);
        }
        return res;
    }
}
```

- [题解](https://leetcode.cn/problems/subarray-sum-equals-k/solutions/238572/he-wei-kde-zi-shu-zu-by-leetcode-solution/?envType=study-plan-v2&envId=top-100-liked)
- 两种解法，枚举 | 前缀和
- 前缀和需要理解等式 $Sum(nums[i],nums[j-1])=suf[i]-suf[j]$，`suf[i]`表示 $Sum(nums[i],nums[n-1])$。
### [滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/)

```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        // 优先队列（大根堆）
        PriorityQueue<int[]> pq = new PriorityQueue<int[]>(new Comparator<int[]>() {
            public int compare(int[] pair1, int[] pair2) {
                // 如果2个数相等，那么index大的在前面
                return pair1[0] != pair2[0] ? pair2[0] - pair1[0] : pair2[1] - pair1[1];
            }
        });
        for (int i = 0; i < k; ++i) {
            pq.offer(new int[]{nums[i], i});
        }
        int[] ans = new int[nums.length - k + 1];
        ans[0] = pq.peek()[0];
        for (int i = k; i < nums.length; ++i) {
            pq.offer(new int[]{nums[i], i});
            // 只有当最大值不在在窗口内则删除，其余的不用管
            while (pq.peek()[1] <= i - k) {
                pq.poll();
            }
            ans[i - k + 1] = pq.peek()[0];
        }
        return ans;
    }
}
```

- [题解](https://leetcode.cn/problems/sliding-window-maximum/solutions/543426/hua-dong-chuang-kou-zui-da-zhi-by-leetco-ki6m/?envType=study-plan-v2&envId=top-100-liked)
- 关键在于如何优化`[i,i+k]`之间的最大值求解过程为 $O(1)$。
- 优先队列，插入和删除的都是 $O(log N)$
- 维护优先队列，只需要移除 index 在`[i,i+k]`窗口外的最大值。
### [最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/)

```java
class Solution {
    public String minWindow(String s, String t) {
        if(t.length() > s.length()) return "";
        HashMap<Character,Integer> map = new HashMap<>();
        char[] arr1 = t.toCharArray();
        for(char c : arr1){
            map.put(c,map.getOrDefault(c,0) + 1);
        }
        int left = 0;
        int right = 0;
        int need = 0;
        char[] arr2 = s.toCharArray();
        int minL = 0;
        int minR = -1;
        while(right < s.length()){
            if(map.containsKey(arr2[right])){
                int size = map.get(arr2[right]);
                map.put(arr2[right],size - 1);
                if(size == 1){
                    need ++;
                }
            }
            // 收缩
            while(left <= right && need == map.size()){
                if(minR == -1 || right - left < minR - minL){
                    minL = left;
                    minR = right;
                }
                if(map.containsKey(arr2[left])){
                    int size = map.get(arr2[left]);
                    map.put(arr2[left],size + 1);
                    if(size == 0){
                        need --;
                    }
                }
                left ++;
            }
            right ++;
        }
        return s.substring(minL,minR + 1);
    }
}
```

- 哈希表记录 t 字符串中字符个数
- 遍历 s 字符串，当哈希表中对应字符的个数减到 0 时，表示子串（窗口内）已经满足特定字符的个数，所以 $need + 1$。
- 当满足 $need=map.size()$ 时，该子串满足记录/收缩条件；比较字串长度来分别设置 minL、minR 索引。
- 同理，当哈希表中对应字符的个数累加到 0 时，表明子串（窗口内）不再满足特定字符的个数，所以 $need - 1$。

# 普通数组
### [最大子数组和](https://leetcode.cn/problems/maximum-subarray/)

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int[] dp = new int[nums.length];
        dp[0] = nums[0];
        int res = dp[0];
        for(int i = 1; i < nums.length; i++){
            dp[i] = Math.max(dp[i-1] + nums[i],nums[i]);
            res = Math.max(dp[i],res);
        }
        return res;
    }
}
```

- 理解 $dp[i] = Math.max(dp[i-1] + nums[i],nums[i])$ 表达式：从 `nums[0] -> nums[i]` 之间连续子数组和的最优解。
### [合并区间](https://leetcode.cn/problems/merge-intervals/)

```java
class Solution {
    public int[][] merge(int[][] intervals) {
        List<int[]> res = new ArrayList<>();
        Arrays.sort(intervals, (o1,o2) -> o1[0] - o2[0]);
        for(int i = 0; i < intervals.length; i ++){
            // 相交 x1<=x2<=y1<=y2(x1<=x2<=y2<=y1)
            while(i+1 < intervals.length && intervals[i][1] >= intervals[i+1][0]){
                // 合并
                intervals[i+1][0] = intervals[i][0];
                intervals[i+1][1] = Math.max(intervals[i][1],intervals[i+1][1]);
                i++;
            }
            // 相隔 x1<y1<x2<y2
            res.add(intervals[i]);
        }
        return res.toArray(new int[res.size()][2]);
    }
}
```

- 理解区间相隔、相交的表达式。
- 排序后根据 $intervals[i][1] >= intervals[i+1][0]$ 判断是否需要合并。
- 合并和后的结果可能需要继续参与下一步判断，所以需要使用 while 循环。
### [轮转数组](https://leetcode.cn/problems/rotate-array/)

**解法一**

```java
class Solution {
    public void rotate(int[] nums, int k) {
        int n = nums.length;
        k %= n;
        int count = 0; // 移动的次数，每一个元素移动1次 共n次
        int cntIndex = 0; // 初始索引
        int nextIndex = k % n ; // 下一个位置索引
        int move = nums[0]; // 移动的元素值
        while (count < n) {
            int next = nums[nextIndex];
            nums[nextIndex] = move;
            move = next;
            count++;
            // 成环
            if (count < n && cntIndex == nextIndex) {
                cntIndex ++;
                move = nums[cntIndex];
                nextIndex =  (cntIndex + k) % n;
                continue;
            }
            nextIndex = (nextIndex + k) % n;
        }
    }
}
```

- 参考环形链表/反转链表的特点。
- 通过 cntIndex 和 nextIndex 变量来判断何时成环。

**解法二**

```java
class Solution {
    public void rotate(int[] nums, int k) {
        int n = nums.length;
        k %= n;
        // 整体反转 0->n-1
        reverse(0,n - 1,nums);
        // 反转0->k -1
        reverse(0,k-1,nums);
        // 反转n-k -> n - 1
        reverse(k,n - 1,nums);
    }
    public void reverse(int l,int r,int[] nums) {
        while (l < r) {
            int temp = nums[l];
            nums[l ++] = nums[r];
            nums[r --] = temp;
        }
    }
}
```

```java
nums   = "--->-->"; k =3
result = "-->--->"; 
// 解释
reverse "--->-->" we can get "<--<-----" 
reverse "<--"     we can get "--><-----" 
reverse "<-----"  we can get "-->----->" 
```

- 引用自[美服](https://leetcode.com/)翻转做法下面的第一条评论

**解法三**

```java
class Solution {
    public void rotate(int[] nums, int k) {
        if(k == 0) return;
        int n = nums.length;
        int index = n - (k % n);
        int[] copy = new int[n];
        int j = 0;
        for(int i = index; i < n; i++){
            copy[j++] = nums[i];
        }
        for(int i = 0; i < index; i++){
            copy[j++] = nums[i];
        }
        for(int i = 0; i < n; i++){
            nums[i] = copy[i];
        }
        return;
    }
}
```

- 扩容
### [除自身以外数组的乘积](https://leetcode.cn/problems/product-of-array-except-self/)

```java
class Solution {
    public int[] productExceptSelf(int[] nums) {
        int n = nums.length;
        int[] answer = new int[n];
        int[] suf = new int[n];
        suf[n-1] = 1;
        for(int i = n-2; i >= 0; i--){
            suf[i] = suf[i+1] * nums[i+1];
        }
        int pre = 1;
        for(int i = 0; i < n; i++){
            answer[i] = pre * suf[i];
            pre *= nums[i];
        }
        return answer;
    }
}
```

- 分别求 i 的前/后缀和

### [缺失的第一个正数](https://leetcode.cn/problems/first-missing-positive/)

```java
class Solution {
    public int firstMissingPositive(int[] nums) {
        int n = nums.length;
        for (int i = 0; i < n; ++i) {
            while (nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] != nums[i]) {
                int temp = nums[nums[i] - 1];
                nums[nums[i] - 1] = nums[i];
                nums[i] = temp;
            }
        }
        for (int i = 0; i < n; ++i) {
            if (nums[i] != i + 1) {
                return i + 1;
            }
        }
        return n + 1;
    }
}
```

- [题解](https://leetcode.cn/problems/first-missing-positive/solutions/304743/que-shi-de-di-yi-ge-zheng-shu-by-leetcode-solution/?envType=study-plan-v2&envId=top-100-liked)
- `x=nums[i]`，如果 $x∈[1,N]$，我们就知道 x 应当出现在数组中的 x−1 的位置，因此交换 `nums[i]` 和 `nums[x−1]`
- 如果 $nums[i]=nums[x−1]$，那么就会无限交换下去，因此控制交换条件 $nums[i]!=nums[x−1]$。
# 矩阵
### [矩阵置零](https://leetcode.cn/problems/set-matrix-zeroes/)

**解法一**

```java
class Solution {
    public void setZeroes(int[][] matrix) {
        int row = matrix.length;
        int col = matrix[0].length;
        int[] rowS = new int[row];
        int[] colS = new int[col];
        for (int i = 0; i < row; i++) {
            for (int j = 0; j < col; j++) {
                if (matrix[i][j] == 0) {
                    // i行j列需要为0
                    rowS[i] = -1;
                    colS[j] = -1;
                }
            }
        }
        for (int i = 0; i < row; i++) {
            if (rowS[i] == -1) {
                for (int j = 0; j < col; j++) {
                    matrix[i][j] = 0;
                }
            }
        }
        for (int i = 0; i < col; i++) {
            if (colS[i] == -1) {
                for (int j = 0; j < row; j++) {
                    matrix[j][i] = 0;
                }
            }
        }
    }
}
```

- 通过状态数组`rowS[i]`、`colS[j]`，分别表示 matrix 数组的 i 行 j 列是否需要全部置换为 0。

**解法二**

```java
class Solution {
    public void setZeroes(int[][] matrix) {
        int row = matrix.length;
        int col = matrix[0].length;
        // 第一行和第一列的状态
        boolean row0 = false;
        boolean col0 = false;
        for (int i = 0; i < row; i++) {
            if (matrix[i][0] == 0) {
                col0 = true;
                break;
            }
        }
        for (int i = 0; i < col; i++) {
            if (matrix[0][i] == 0) {
                row0 = true;
                break;
            }
        }
        // 用matrix的第一行和第一列记录matrix的状态
        for (int i = 1; i < row; i++) {
            for (int j = 1; j < col; j++) {
                if (matrix[i][j] == 0) {
                    matrix[i][0] = 0;
                    matrix[0][j] = 0;
                }
            }
        }
        for (int i = 1; i < row; i++) {
            if (matrix[i][0] == 0) {
                for (int j = 0; j < col; j++) {
                    matrix[i][j] = 0;
                }
            }
        }
        for (int i = 1; i< col; i++) {
            if (matrix[0][i] == 0) {
                for (int j = 0; j < row; j++) {
                    matrix[j][i] = 0;
                }
            }
        }
        if (row0) {
            for (int i = 0; i < col; i++) {
                matrix[0][i] = 0;
            }
        }
        if (col0) {
            for (int i = 0; i < row; i++) {
                matrix[i][0] = 0;
            }
        }
    }
}
```

- [题解](https://leetcode.cn/problems/set-matrix-zeroes/solutions/3638986/zhuang-tai-shu-zu-yuan-shu-zu-ya-suo-kon-py88/?envType=study-plan-v2&envId=top-100-liked)
- 这个常量空间的解决方案，关键在于利用自身数组的第 1 行、第 1 列作为原数组 i 行 j 列存在 0 的状态数组。
### [螺旋矩阵](https://leetcode.cn/problems/spiral-matrix/)

```java
class Solution {
    public List<Integer> spiralOrder(int[][] matrix) {
      int m = matrix.length;
      int n = matrix[0].length;
      List<Integer> res = new ArrayList<>();
      int left = 0;
      int right = n-1;
      int top = 0;
      int down = m-1;
      while(res.size() < m*n){
        for(int i = left; i <= right; i++){
          res.add(matrix[top][i]);
        }
        for(int i = top+1; i <= down; i++){
          res.add(matrix[i][right]);
        }
        if(left < right && top < down){
          for(int i = right - 1; i > left; i--){
            res.add(matrix[down][i]);
          }
          for(int i = down; i > top; i--){
            res.add(matrix[i][left]);
          }
        }
        left ++;
        right --;
        top ++;
        down --;
      }
      return res;
    }
}
```

- [题解](https://leetcode.cn/problems/spiral-matrix/solutions/3639254/an-ceng-bian-li-ju-zhen-tong-guo-fang-xi-s7y6/?envType=study-plan-v2&envId=top-100-liked)
- 向右 $[left,rigth]$、向下 $[top+1,down]$、向左 $[right-1,left)$、向上 $[down,top)$
- 向左和向上遍历为了避免和向右、向下遍历的是同一行同一列，需要满足 $left<right,top<down$