---
title: Leetcode Hot-100 题解
slug: leetcode-hot100
date: 2025-08-10
categories: 算法
tags:
  - leetcode
  - hot-100
---
# 哈希
### [两数之和](https://leetcode.cn/problems/two-sum/)

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        HashMap<Integer,Integer> map = new HashMap<>();
        for(int i = 0; i < nums.length; i ++){
            int a = nums[i];
            if(map.containsKey(target - a)){
                return new int[] {i,map.get(target - a)};
            }
            map.put(a,i);
        }
        return null;
    }
}
```

-  $a + b = c$ 题目类型，因为 $b = c - a$，所以遍历 a，查询 b 即可。
- 使用哈希表以 $O(1)$ 复杂度查询。
### [字母异位词分组](https://leetcode.cn/problems/group-anagrams/)

```java
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        HashMap<String, List<String>> hashMap = new HashMap<>();
        for (String str : strs) {
            // 转为字符数组排序
            char[] array = str.toCharArray();
            Arrays.sort(array);
            // 转为String为key，做判断
            String key = Arrays.toString(array);
            // 判断是否存在该单词
            List<String> ans = hashMap.getOrDefault(key, new ArrayList<>());
            ans.add(str);
            hashMap.put(key,ans);
        }
        // 结果集
        return new ArrayList<List<String>>(hashMap.values());
    }
}
```

- 将字符串排序后作为 key，从而得到字母异位词分组
- `Collection<T> values = hashMap.values()`，`list.addAll(Collection<? extends E> c)`
### [最长连续序列](https://leetcode.cn/problems/longest-consecutive-sequence/)

```java
class Solution {
    public int longestConsecutive(int[] nums) {
        Set<Integer> set = new HashSet<>();
        // 去重
        for(int num : nums){
            set.add(num);
        }
        int maxL = 0;
        //x-1 的序列长度 >> x 的序列长度
        for(int x : set){
            if(set.contains(x - 1)){
                continue;
            }else{
                int curL = 1;
                while(set.contains(x + 1)){
                    curL ++;
                    x ++;
                }
                maxL = Math.max(maxL,curL);
            }
        }
        return maxL;
    }
}
```

- [题解](https://leetcode.cn/problems/longest-consecutive-sequence/solutions/3005726/ha-xi-biao-on-zuo-fa-pythonjavacgojsrust-whop/?envType=study-plan-v2&envId=top-100-liked)
- 哈希去重，如果哈希表存在 x - 1，那么以 x - 1 开始的数字序列长度一定大于 x。
# 双指针
### [移动零](https://leetcode.cn/problems/move-zeroes/)

```java
class Solution {
    public void moveZeroes(int[] nums) {
        int head = 0;
        int tail = 0;
        // 将不为0的num[tail]依次插入num[head]
        while (tail < nums.length) {
            if (nums[tail] != 0) {
                int temp = nums[head];
                nums[head] = nums[tail];
                nums[tail] = temp;
                head++;
            }
            tail ++;
        }
    }
}
```

- 参考栈的设计，不为 0 的元素依次入栈
### [盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/)

```java
class Solution {
    public int maxArea(int[] height) {
        int left = 0;
        int right = height.length - 1;
        int area = -1;
        while(left < right) {
            area = Math.max(area,(right - left) * Math.min(height[left],height[right]));
            // 移动短板
            if(height[left] >= height[right]){
                right --;
            }else{
                left ++;
            }
        }
        return area;
    }
}
```

- [题解](https://leetcode.cn/problems/container-with-most-water/solutions/11491/container-with-most-water-shuang-zhi-zhen-fa-yi-do/?envType=study-plan-v2&envId=top-100-liked)
- 若向内**移动短板**，水槽的短板`min(h[left],h[right])`可能变大，因此下个水槽的面积**可能增大**。
- 若向内**移动长板**，水槽的短板`min(h[left],h[right])`不变或变小，因此下个水槽的面积**一定变小**。
### [三数之和](https://leetcode.cn/problems/3sum/)

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        List<List<Integer>> res = new ArrayList<>();
        // a + b + c = sum
        for(int i = 0; i < nums.length - 2; i++) {
            int a = nums[i];
            // 去重
            if(i > 0 && nums[i] == nums[i - 1]) continue;
            // 双指针枚举[i + 1, nums.length]中元素
            int l = i + 1;
            int r = nums.length - 1;
            while(l < r){
                int sum = a + nums[l] + nums[r];
                if(sum > 0){
                    while(l < r && nums[r] == nums[--r]);
                }else if(sum < 0) {
                    while(l < r && nums[l] == nums[++l]);
                }else{
                    List<Integer> ans = new ArrayList<>();
                    ans.add(a);
                    ans.add(nums[l]);
                    ans.add(nums[r]);
                    res.add(ans);
                    // 去重
                    while(l < r && nums[r] == nums[--r]);
                    while(l < r && nums[l] == nums[++l]);
                }
            }
        }
        return res;
    }
}
```

- [题解](https://leetcode.cn/problems/3sum/solutions/11525/3sumpai-xu-shuang-zhi-zhen-yi-dong-by-jyd/?envType=study-plan-v2&envId=top-100-liked)
- 双指针 l , r 交替向中间移动，记录 `nums[i] + nums[l] + nums[r] == 0` 的 l , r 组合。
- 通过排序，$a+b+c=sum$ 中，sum 的值可以通过移动 l , r 指针控制。
- 排序后，`nums[i-1]`得到的`(i-1,l,r)`结果一定包含了`nums[i]`的结果，从而解决重复。
### [接雨水](https://leetcode.cn/problems/trapping-rain-water/)

```java
class Solution {
    public int trap(int[] height) {
        // maxL[i]为左边柱子的最大高度，包括本身
        int[] maxL = new int[height.length]; 
        // maxL[i]为右边柱子的最大高度，包括本身
        int[] maxR = new int[height.length]; 
        maxL[0] = height[0];
        maxR[height.length - 1] = height[height.length - 1];
        for (int i = 1; i < height.length; i++) {
            maxL[i] = Math.max(maxL[i - 1], height[i]);
        }
        for (int i = height.length - 2; i >= 0; i --) {
            maxR[i] = Math.max(maxR[i + 1], height[i]);
        }
        // 接的雨水为当前柱子i Min{maxL[i],maxR[i]} - height[i]
        int cnt = 0;
        for(int i = 1; i < height.length - 1; i++) {
            int res = Math.min(maxL[i - 1],maxR[i + 1]) - height[i];
            cnt += Math.max(res, 0);
        }
        return cnt;
    }
}
```

- [题解](https://leetcode.cn/problems/trapping-rain-water/solutions/692342/jie-yu-shui-by-leetcode-solution-tuvc/)
- 木桶理论，dp 的代码更好理解。
- 对于每一列可以接的雨水取决于左右两边最高的短木板减去当前木板高度（如下图所示）。

![](https://cdn.img.turingzy.cn/2025/Hot-100-0811.webp)
# 滑动窗口
### [无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        if(s.length() <= 0) return 0;
        char[] arr = s.toCharArray();
        Set<Character> set = new HashSet<>();
        int head = 0;
        int tail = 1;
        set.add(arr[0]);
        int res = 1;
        while(tail < arr.length){
            // 伸缩
            while(head < tail && set.contains(arr[tail])) {
                set.remove(arr[head]);
                head ++;
            }
            // 扩张
            set.add(arr[tail]);
            res = Math.max(res,tail - head + 1);
            tail ++;
        }
        return res;
    }
}
```

- 不定长滑动窗口
- 通过哈希表去重
### [找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/)

```java
class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        if(s.length() < p.length()) return new ArrayList<>();
        int[] base = new int[26];
        for(char c: p.toCharArray()) {
            base[c - 'a'] ++;
        }
        int[] cnt = new int[26];
        for(int i = 0; i < p.length(); i++){
            cnt[s.charAt(i) - 'a'] ++;
        }
        int l = 0;
        int r = p.length() - 1;
        List<Integer> res = new ArrayList<>();
        while(r < s.length()){
            if(Arrays.equals(cnt,base)){
                res.add(l);
            }
            // 防止越界
            if(r == s.length() - 1){
                break;
            }
            cnt[s.charAt(l++) - 'a'] --;
            cnt[s.charAt(++r) - 'a'] ++;
        }
        return res;
    }
}
```

- 定长滑动窗口
- 通过`Arrays.equals()`来比较两个数组的值是否相等（只包含小写字母，比较耗时可忽略）。
- 因为是先定好了窗口（第二个 for 循环）才开始比较，所以需要注意是否索引越界。
